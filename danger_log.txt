- 2/14 We found that every time when we tried to load the page, at the beginning it worked but some time later the browser crashed down and the page failed to be loaded fully. We found this issue was caused by the corruption of file descriptor of the socket that connected the proxy to the server because we had defined this file descriptor to be a member of Proxy class instead of declaring a new one for each new connection with the server. We fixed this issue and got the "CONNECT" method run smoothly.

- 2/16 We found when dealing with "GET" method, the proxy might store the content in the HTTP response body in a weird way such that when sending it to client (firefox browser) later on, the client cannot render it correctly. We found this issue was caused by using C++ string to hold the response. After some online search, we found one of the main reasons for this issue was because HTTP response body for the chunked case might include "\0", which might be interpreted as end of string by C++ string. We fixed this issue by replacing C++ string with vector of char. We could then successfully receive and store the HTTP response.

- 2/18 When handling "GET" method, we need to determine whether it's of content-length type or chunked type. This means we have to first receive exactly until the end of HTTP response header, then parse it to determine the type. We solved this problem using a buffer of size 1 to receive the header part so that we can check the end of header easily because we built the response header character by character.

- 2/20 We found when using recv() function to receive response from server for the content-length case, if using a fixed-sized buffer, it was hard to receive the exact number of bytes specified by the content length. The reason was that recv() function might not receive the exact number of bytes specified by the third parameter of this function. We've developed two approaches to solve this problem. The first one is using a buffer of size one. The second is using a buffer of varying size, which is set to be the remained number of bytes every time until all number of bytes were successfully received. The second approach run faster than the first one. But considering the robustness after testing several websites, we finally used the first approach.

- 2/22 We found when trying to send response obtained from server side to the client, firefox browser kept trying to load the page but never ended. We found this issue was caused by forgetting to close the socket after receiving and sending data. What a lesson! We fixed this issue by closing the socket and "GET" finally worked!

- 2/24 We found when implementing the HTTP caching functionality, even when the response had "expires" or "max-age" field, our log would always log "cached, but requires revalidation". We found the reason was we had not handled the case of a response had neither "max-age" nor "expires" field. We fixed this issue by adding codes to handle this part.

- 2/25 We found our codes had not handled most failure cases. We fixed this issue by adding codes which can throw and catch exceptions to make our codes more robust to external failures. More specifically, the failures we've handled include: malformed request, we handle it by sending 400 back to client and close the socket connected with client, the exception guarantee we made is strong guarantee. The second type of failures we handled is sending or receiving failure when proxy trying to get response from server or trying to send the response back to client. For the former case, it was usually caused by a corrupted response from the server side. We handled it by first closing the socket to server, then we sent a "502 Bad Gateway" to client, finally we closed the socket to client. It has strong exception guarantee. For the later case, if an error happened when proxy trying to send the response back to the client, we handled it in the same way.

- 2/26 We found our log printed one extra line for all the log messages that contained a time as its end. We found that was because if you call the asctime() function, it would include a newline character at the end. We fixed this issue by removing the newline character we added after calling asctime() function in stringstream.

- 2/27 We found that when we run the codes in docker container, the program sometimes exited with code 139. We searched online and found this problem was usually caused by double free. But our codes run with no problem outside of docker. We've checked our codes carefully and have not found double free problem. We guessed this problem was caused by some abnormal situation that led to some double free case. We've not managed to fix this issue due to time limit. In this situation, we suggested the user to rebuild the docker and rerun the program or simply run it outside of docker.

NOTE: 
We designed four classes: proxy class for the major functionalities, Http Response and http Request class that handles http response and request respectively, including 
parse them into useful fields and build response and request to be sent to client and 
server. Finally we have the cache class that handles the http caching.

To handle the cache synchronization, we locked the cache each time we read and wrote into a cache node. We used a mutex here. Another approach would be to add read and write lock separately. For the read cache node operation, a read lock could be used such that several clients can read and get a lock simultaneously with no problem. For the write cache node operation, only one client can write at one time. This approach would improve the performance and its advantage over simple mutex is it does not block other clients for read operation when one client is reading the cache node.